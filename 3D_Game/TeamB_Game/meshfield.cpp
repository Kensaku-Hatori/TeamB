//==============================================
//
// メッシュ床表示処理[meshfield.cpp]
// Author:kaiti
//
//==============================================

#include "meshfield.h"
#include <string.h>

//グローバル変数宣言
LPDIRECT3DVERTEXBUFFER9 g_pVtxBuffMeshfield = NULL;						//頂点情報へのポインタ
LPDIRECT3DTEXTURE9 g_pTextureMeshfield[MAX_TEX_FIELD] = {};				//テクスチャへのポインタ

MeshField g_Meshfield[MESH_NUM_MAX];									//ポリゴン(横)の構造体
static char fieldtexName[MAX_TEX_FIELD][32] = { NULL };					//テクスチャファイル名保存用
int flmaxVtx = 0, flpolyNum = 0;						//頂点数、ポリゴン数、インデックス数保存用

//=================================
// メッシュ床の初期化処理
//=================================
void InitMeshfield(void)
{
	//デバイスの取得
	LPDIRECT3DDEVICE9 pDevice = GetDevice();

	//頂点数、ポリゴン数、インデックス数初期化
	flmaxVtx = 0;
	flpolyNum = 0;

	for (int nCnt = 0; nCnt < MESH_NUM_MAX; nCnt++)
	{
		//構造体の初期化
		g_Meshfield[nCnt].pos = D3DXVECTOR3(-900.0f, 0.0f, 900.0f);		//位置
		g_Meshfield[nCnt].rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			//向き
		g_Meshfield[nCnt].IdxBuffMeshField = { NULL };					//インデックスバッファ
		g_Meshfield[nCnt].textype = 0;									//テクスチャタイプ
		g_Meshfield[nCnt].nDiviX = 0;									//分割数x(0にしたらnullptr)
		g_Meshfield[nCnt].nDiviY = 0;									//分割数y
		g_Meshfield[nCnt].nDiviZ = 0;									//分割数z(0にしたらnullptr)
		g_Meshfield[nCnt].nWidth = 0;									//幅
		g_Meshfield[nCnt].nHeight = 0;									//高さ
		g_Meshfield[nCnt].nIndex = 0;									//インデックス
		g_Meshfield[nCnt].bUse = false;									//使用していない状態にする
	}
}

//===============================
// メッシュ床の終了処理
//===============================
void UninitMeshfield(void)
{
	//テクスチャの破棄
	for (int nCnt = 0; nCnt < MAX_TEX_FIELD; nCnt++)
	{
		if (g_pTextureMeshfield[nCnt] != NULL)
		{
			g_pTextureMeshfield[nCnt]->Release();
			g_pTextureMeshfield[nCnt] = NULL;
		}
	}

	//頂点バッファの破棄
	if (g_pVtxBuffMeshfield != NULL)
	{
		g_pVtxBuffMeshfield->Release();
		g_pVtxBuffMeshfield = NULL;
	}

	for (int nCnt = 0; nCnt < MESH_NUM_MAX; nCnt++)
	{
		//インデックスバッファの破棄
		if (g_Meshfield[nCnt].IdxBuffMeshField != NULL)
		{
			g_Meshfield[nCnt].IdxBuffMeshField->Release();
			g_Meshfield[nCnt].IdxBuffMeshField = NULL;
		}
	}
}

//===============================
// メッシュ床の更新処理
//===============================
void UpdateMeshfield(void)
{

}

//===============================
// メッシュ床の描画処理
//===============================
void DrawMeshfield(void)
{
	//デバイスの取得
	LPDIRECT3DDEVICE9 pDevice = GetDevice();
	
	//計算用マトリックス
	D3DXMATRIX mtxRot, mtxTrans;

	for (int nCnt = 0; nCnt < MESH_NUM_MAX; nCnt++)
	{
		if (g_Meshfield[nCnt].bUse == true)
		{
			//ワールドマトリックスの初期化
			D3DXMatrixIdentity(&g_Meshfield[nCnt].mtxWorld);

			//向きを反転
			D3DXMatrixRotationYawPitchRoll(&mtxRot, g_Meshfield[nCnt].rot.y, g_Meshfield[nCnt].rot.x, g_Meshfield[nCnt].rot.z);
			D3DXMatrixMultiply(&g_Meshfield[nCnt].mtxWorld, &g_Meshfield[nCnt].mtxWorld, &mtxRot);

			//位置を反映
			D3DXMatrixTranslation(&mtxTrans, g_Meshfield[nCnt].pos.x, g_Meshfield[nCnt].pos.y, g_Meshfield[nCnt].pos.z);
			D3DXMatrixMultiply(&g_Meshfield[nCnt].mtxWorld, &g_Meshfield[nCnt].mtxWorld, &mtxTrans);

			//ワールドマトリックスの設定
			pDevice->SetTransform(D3DTS_WORLD, &g_Meshfield[nCnt].mtxWorld);

			//頂点バッファをデータストリームに設定
			pDevice->SetStreamSource(0, g_pVtxBuffMeshfield, 0, sizeof(VERTEX_3D));

			//インデックスバッファをデータストリームに設定
			pDevice->SetIndices(g_Meshfield[nCnt].IdxBuffMeshField);

			//頂点フォーマットの設定
			pDevice->SetFVF(FVF_VERTEX_3D);

			//テクスチャの設定
			pDevice->SetTexture(0, g_pTextureMeshfield[g_Meshfield[nCnt].textype]);

			//メッシュ床を描画
			pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLESTRIP, 0, 0, flmaxVtx, 0, flpolyNum);
		}
	}
}

//===============================
// メッシュ床の設定処理
//===============================
void SetMeshfield(D3DXVECTOR3 pos, D3DXVECTOR3 rot, int textype, int nDiviX,int nDiviY, int nDiviZ, int nWidth, int nHeight)
{
	//デバイスの取得
	LPDIRECT3DDEVICE9 pDevice = GetDevice();

	//頂点情報へのポインタ
	VERTEX_3D* pVtx = NULL;

	//インデックスへのポインタ
	WORD* pIdx = NULL;

	for (int nCnt = 0; nCnt < MESH_NUM_MAX; nCnt++)
	{
		if (g_Meshfield[nCnt].bUse==false)
		{
			g_Meshfield[nCnt].pos = pos;						//位置
			g_Meshfield[nCnt].rot = rot;						//向き
			g_Meshfield[nCnt].textype = textype;				//テクスチャタイプ
			g_Meshfield[nCnt].nDiviX = nDiviX;					//分割数x
			g_Meshfield[nCnt].nDiviY = nDiviY;					//分割数y
			g_Meshfield[nCnt].nDiviZ = nDiviZ;					//分割数z
			g_Meshfield[nCnt].nWidth = nWidth;					//幅
			g_Meshfield[nCnt].nHeight = nHeight;				//高さ
			g_Meshfield[nCnt].bUse = true;						//使用している状態にする

			flmaxVtx += (g_Meshfield[nCnt].nDiviX + 1) * (g_Meshfield[nCnt].nDiviZ + 1);											//頂点数
			flpolyNum += (g_Meshfield[nCnt].nDiviZ * 2) * (g_Meshfield[nCnt].nDiviX + (g_Meshfield[nCnt].nDiviZ - 1) * 2);			//ポリゴン数
			int flindexNum = (g_Meshfield[nCnt].nDiviZ * 2) * (g_Meshfield[nCnt].nDiviX + (g_Meshfield[nCnt].nDiviZ * 2) - 1);		//インデックス

				//インデックスバッファの生成
			pDevice->CreateIndexBuffer(sizeof(WORD) * flindexNum,
				D3DUSAGE_WRITEONLY,
				D3DFMT_INDEX16,
				D3DPOOL_MANAGED,
				&g_Meshfield[nCnt].IdxBuffMeshField,
				NULL);


			break;
		}
	}

	//頂点バッファの生成
	pDevice->CreateVertexBuffer(sizeof(VERTEX_3D) * flmaxVtx,
		D3DUSAGE_WRITEONLY,
		FVF_VERTEX_3D,
		D3DPOOL_MANAGED,
		&g_pVtxBuffMeshfield,
		NULL);

	for (int nCnt = 0; nCnt < MESH_NUM_MAX; nCnt++)
	{
		if (g_Meshfield[nCnt].bUse == true)
		{
			//頂点バッファをロックし、頂点情報へのポインタを取得
			g_pVtxBuffMeshfield->Lock(0, 0, (void**)&pVtx, 0);

			//頂点情報の設定
			for (int nCntZ = 0; nCntZ <= g_Meshfield[nCnt].nDiviZ; nCntZ++)
			{
				for (int nCntX = 0; nCntX <= g_Meshfield[nCnt].nDiviX; nCntX++)
				{
					//頂点座標の設定
					pVtx[0].pos = D3DXVECTOR3(-g_Meshfield[nCnt].nWidth + (g_Meshfield[nCnt].nWidth * nCntX), 0.0f, g_Meshfield[nCnt].nHeight - (g_Meshfield[nCnt].nHeight * nCntZ));

					//法線ベクトルの設定
					pVtx[0].nor = D3DXVECTOR3(0.0f, 1.0f, 0.0f);

					//頂点カラーの設定
					pVtx[0].col = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);

					//テクスチャ座標の設定
					pVtx[0].tex = D3DXVECTOR2((1.0f / g_Meshfield[nCnt].nDiviX) * nCntX, (1.0f / g_Meshfield[nCnt].nDiviZ) * nCntZ);

					pVtx++;
				}
			}

			//頂点バッファをアンロック　
			g_pVtxBuffMeshfield->Unlock();

			//インデックスバッファをロック
			g_Meshfield[nCnt].IdxBuffMeshField->Lock(0, 0, (void**)&pIdx, 0);

			int nCntX;
			for (int nCntZ = 0; nCntZ < g_Meshfield[nCnt].nDiviZ; nCntZ++)
			{
				for (nCntX = 0; nCntX <= g_Meshfield[nCnt].nDiviX; nCntX++)
				{
					//インデックスの設定
					pIdx[0] = (g_Meshfield[nCnt].nDiviX + 1) * (nCntZ + 1) + nCntX;
					pIdx[1] = nCntX + (nCntZ * (g_Meshfield[nCnt].nDiviX + 1));

					pIdx += 2;
				}

				if (nCntZ < g_Meshfield[nCnt].nDiviZ - 1)
				{
					pIdx[0] = (nCntX - 1) + (nCntZ * (g_Meshfield[nCnt].nDiviX + 1));
					pIdx[1] = (nCntX - 1) + (nCntZ * (g_Meshfield[nCnt].nDiviX + 1)) + (g_Meshfield[nCnt].nDiviX + 2) * (nCntZ + 1);

					pIdx += 2;
				}
			}

			//インデックスバッファのアンロック
			g_Meshfield[nCnt].IdxBuffMeshField->Unlock();
		}
	}
}

//===============================
// メッシュ床のテクスチャ設定処理
//===============================
void SetfieldTexture(char* pFileName, int TexIndx)
{
	//デバイスの取得
	LPDIRECT3DDEVICE9 pDevice = GetDevice();

	strcpy(fieldtexName[TexIndx], pFileName);

	//テクスチャの読込
	D3DXCreateTextureFromFile(pDevice,
		&fieldtexName[TexIndx][0],
		&g_pTextureMeshfield[TexIndx]);
}
